\section{Implementation}
\phantomsection
The initial step that was done, was the understanding of the purpose of the application. Different ideas had to be analyzed and decisions were made whether they should be included in the application or not. From the remaining set of ideas, some of them were labeled as a high priority and the others were decided to be considered as optional. Actually, this was done in order to set the developer on the right objectives. The high priority ideas, were considered essential for the application's main purpose. Given the time limit and the unforseen factors that could affect it, the most important tasks were to be developed first, leaving the other ones to be executed if there was time left. So, before beginning the implementation, QTK was conceptually divided into four main distinctive fragments:
\begin{enumerate}
  \item {User interface}
  \item {Quiz Managing}
  \item {Quiz generation}
  \item {Quiz processing}
\end{enumerate}

These four elements of QTK will be amply described later in this chapter.

Ruby on Rails was the framework used in developing the web application. The default SQLite database which was included in the generated Rails application, was considered to be sufficient for our purposes and no other alternatives were searched. The following list of possibly to be used technologies was considered:
\begin{enumerate}
  \item Camellia
  \item OpenCV
  \item Tesseract
  \item rqrcode
  \item qrencoder
  \item qrio
  \item zxing
  \item qrdecoder
\end{enumerate}
Due to different reasons, none of these technologies were used in the final version of the application.

\subsection{User Interface}
The first step in creating the user interface, was to create the sketches of some of the web pages. The mockflow web app \cite{mockflow} was used for this purpose. The figures \ref{main_page_mockup} and \ref{quiz_generate_mockup} are the mockups based on which the real front-end was created.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.9\textwidth]{main_page_mockup}
\caption{QTK's main page mockup}\label{main_page_mockup}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.9\textwidth]{quiz_generate_mockup}
\caption{QTK's quiz generation page mockup}\label{quiz_generate_mockup}
\end{figure}


Bootstrap\cite{bootstrap} framework was used in developing the front-end of the application. Figures \ref{main_page_qtk} and \ref{generate_quiz_qtk} illustrate the application of this framework in the QTK's user interface.
The View layer, contain the templates, which are of ``Haml'' format(the default format is ``erb''). They constitute the interface which is displayed to the user. The contents can be text, images, tables, videos, hyperlinks and other elements which give the user the possibility to interact with the system. A haml formatted template which uses Bootstrap with CSS, HTML and JavaScript for styling is exemplified in listing \ref{new_question_haml}.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.9\textwidth]{main_page_qtk}
\caption{QTK's main page}\label{main_page_qtk}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.9\textwidth]{generate_quiz_qtk}
\caption{QTK's quiz view page mockup}\label{generate_quiz_qtk}
\end{figure}

\lstinputlisting[language=Ruby, caption={Template \textit{new.html.haml} corresponding to action \textit{new} of QuestionsController}, label=new_question_haml]{../src/new.html.haml}

\subsection{Quiz managing}
Quiz managing covers a list of things:
\begin{itemize}
  \item Course creation, renaming and deletion
  \item Quiz creation, renaming and deletion
  \item Question creation, editing and deletion
  \item Answer creation, editing and deletion
  \item Question group creation and deletion
\end{itemize}

These items, combined together, make the management system specific to QTK. They are implemented using the Rails framework and use all the layers proprietary to it. The model layer is used to create the classes representing the objects defined as course, quiz, question, answer and question group. A Model layer Question class example is given in listing \ref{question_class}.
The Controller, which serves as a bridge between the View and the Model layers contains the actions which react to the incoming requests. In listing \ref{students_class} is shown the StudentsController class. 

There is another type of classes which should be mentioned. These are the migration classes, which inherit from the ActiveRecord::Migration class. The CreateAnswers class \ref{create_answers}, for example, is designed to create the table \textit{answers} in the database, with the specified fields. In this migration, is also indicated the foreign key of the table \textit{questions} which announces the relationship between these tables.

\lstinputlisting[language=Ruby, caption={Question class}, label=question_class]{../src/question.rb}

\lstinputlisting[language=Ruby, caption={StudentsController class}, label=students_class]{../src/students_controller.rb}

\lstinputlisting[language=Ruby, caption={CreateAnswers class}, label=create_answers]{../src/create_answers.rb}


\subsection{Quiz Generation}
Two gems(libraries) were additionally used to implement the ``quiz generation'' part of the application: Strokes and Prawn. Strokes is used to generate the QR codes and Prawn is used to generate the PDF files. The main idea was to give the user the possibility to generate the quizes in different ways. So, options were provided for this purpose. Quizes can be generated based on the chosen student groups, so the generated pdf would have copies created specifically for each student of those student groups. Or, the \textit{random} option can be choosed so the questions in every copy would be arranged in a random fashion.

When the user chooses to generate a quiz pdf, he selects the options he wants and sends the request to the server. Here, the \textit{GeneratedQuizzesController} class, which is responsible for catching this specific request, uses the \textit{create} \ref{create_method} method to commence the generation process in the backend. 

The \textit{GeneratedQuizzesHelper} module has a method named \textit{gen\_copies}, which is responsible for creating the necessary Copy class instances and persist them to the database, based on the options the user had chosen earlier. The necessity to create a separate method inside this module was because this process has its specific logic, which shouldn't be exposed in the controller action directly. By this, it is meant that some of the options were complementary, others were not. For example, the \textit{number of copies} option is interfering with the \textit{student group} option, because the second option's purpose is to create quiz copies based on the student's names, which in turn result in a determined number of final copies. Another option interference is the \textit{versions number} and the \textit{random} options. By selecting the number of versions to be generated for a quiz, it implies that each version will have the questions randomly sorted. So, once again, the other option becomes unnecessary to be selected.

The biggest role in the \textit{quiz generation} process has the \textit{QuizPdf} class. This class inherits from the \textit{Prawn::Document} class. It uses the Prawn's API to render all the required elements on the page. Here is a list of those elements: 
\begin{itemize}
  \item Questions
  \item Answers
  \item Squares next to the answers
  \item Title
  \item Student name and group
  \item QR code
  \item Markers(circles) in each corner
  \item Page number
\end{itemize}

The \textit{set\_header} presented in listing \ref{set_header} of the \textit{QuizPdf} class is responsible for the QR code generation, title, student name, student group name and page number rendering and the stroking of the markers. 

The QR code is used to store some information in order to easily read it afterwards. In our case, the copy id of the \textit{Copy} class instance 
is encoded in the QR code. Also the current page number of the copy is stored in the QR code. This information will be critical in the later image processing part of the QTK's implementation. 

The markers, which are positioned at corners of the page, are circles with a 10 pixel radius on a 612x792 resolution pdf page. They are also going to be used in the image processing part, by using them as pivots when searching for the answer squares' coordinates.

The \textit{set\_questions} method is responsible for rendering the questions' and the answers' text. But, besides that, it draws the answers' squares, that are used by the students to select an answer when taking the quiz. Another thing related to the image processing is also being prepared at this point and that is the storing the ids of the questions and answers and the squares' left-top corner coordinates into a hash. At the end of the \textit{QuizPdf's} class execution, this hash is stored in the database in the copies table through the Copy class model. It is stored in the \textit{squares\_xy} field of that table.

After the \textit{QuizPdf} class instance is created and assigned to a variable, that instance is rendered into a pdf file in the web browser. 

\begin{lstlisting}[language=Ruby, caption={Create method of the GeneratedQuizzesController class}, label=create_method]
def create
  @user = current_user
  @generated_quiz = @user.generated_quizzes.new(generated_quiz_params)
  @generated_quiz.save
  GeneratedQuizzesHelper.gen_copies(@generated_quiz)
  # Generate pdf document
  pdf = QuizPdf.new(@generated_quiz)
  send_data pdf.render, filename: 'report.pdf', type: 'application/pdf', disposition: 'inline'
end
\end{lstlisting}

\lstinputlisting[language=Ruby, caption={QuizPdf's \textit{set\_header} method}, label=set_header]{../src/set_header.rb}



\subsection{Quiz Processing}

When the user uploads a set of files, which are the generated quizes' scanned images, the system starts a background job for every one of them. These background jobs are the ones that do the image processing. 

The \textit{ScannedQuiz} model class found in listing \ref{scanned_quiz_class} is responsible for storing the metadata of one uploaded image per class instance and has a relative table in the database. But the first class to be awakened when the user uploads something, is the UsersController class. It has the \textit{upload} action, which takes each image and creates a ScannedQuiz instance for it. At the model level, when these images are created and commited to the database, a callback is initiating a job. 


\lstinputlisting[language=Ruby, caption={ScannedQuiz class}, label=scanned_quiz_class]{../src/scanned_quiz.rb}

The \textit{ScansProcessingJob} is the class containing all the logic behind the processing of the images. The first method that should be mentioned, is \textit{read\_qr} in listing \ref{read_qr}. Reading the QR code's information is critical to the inception of the image processing. Whether it is read or not sets the processing to the next step or returns the specific error. The top-left corner of the image is cropped and passed to the \textit{ZBar::Image}(ZBar being the library used to decode QR codes) class for processing. The cropping is performed using the \textit{MiniMagick} library, which is a Ruby wrapper for \textit{ImageMagick} command line software. Also, in this method, is performed some image filtering and more specifically, the image is being thresholded by 60\%. The \textit{threshold} option provided by MiniMagick transforms a grayscale image, to a black and white one. 

\lstinputlisting[language=Ruby, caption={\textit{read\_qr} method}, label=read_qr]{../src/read_qr.rb}



\clearpage